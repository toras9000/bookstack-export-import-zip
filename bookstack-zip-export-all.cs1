#!/usr/bin/env -S dotnet run --file
#:package BookStackApiClient@25.12.0-lib.0
#:package Kokuban@0.2.0
#:package Lestaly.General@0.114.0
#:package RefFile@0.2.0
#:property PublishAot=false
using System.Text.Json;
using BookStackApiClient;
using BookStackApiClient.Utility;
using Kokuban;
using Lestaly;
[assembly: RefFile(".common.cs1")]

var settings = new
{
    BookStack = new
    {
        // Target BookStack service address
        ServiceUrl = new Uri("http://localhost:8831/"),

        // API token of the user performing the export
        ApiToken = "00001111222233334444555566667777",

        // API secret of the user performing the export
        ApiSecret = "88889999aaaabbbbccccddddeeeeffff",
    },

    Local = new
    {
        // Destination directory for export data.
        ExportDir = ThisSource.RelativeDirectory("exports"),
    },
};

return await Paved.ProceedAsync(async () =>
{
    // Prepare console
    using var signal = new SignalCancellationPeriod();

    // Title display
    Console.WriteLine($"Exporting data from BookStack");
    Console.WriteLine($"  Service Address: {settings.BookStack.ServiceUrl}");
    Console.WriteLine();

    // Create client and helper
    var apiUri = new Uri(settings.BookStack.ServiceUrl, "/api/");
    using var http = new HttpClient();
    using var client = new BookStackClient(apiUri, settings.BookStack.ApiToken, settings.BookStack.ApiSecret);
    using var helper = new BookStackClientHelper(client, signal.Token);
    helper.LimitHandler += (args) =>
    {
        Console.WriteLine(Chalk.Yellow[$"Caught in API call rate limitation. Rate limit: {args.Exception.RequestsPerMin} [per minute], {args.Exception.RetryAfter} seconds to lift the limit."]);
        Console.WriteLine(Chalk.Yellow[$"It will automatically retry after a period of time has elapsed."]);
        Console.WriteLine(Chalk.Yellow[$"[Waiting...]"]);
        return ValueTask.CompletedTask;
    };

    // Detect BookStack version
    var system = await helper.Try((c, t) => c.SystemAsync(t));
    var version = BookStackVersion.Parse(system.version);
    if (version < BookStackVersion.Parse("25.11")) throw new PavedMessageException("Unsupported BookStack version.", PavedMessageKind.Warning);

    // Determine output directory
    var exportTime = DateTime.Now;
    var exportDir = settings.Local.ExportDir.RelativeDirectory($"{exportTime:yyyy.MM.dd-HH.mm.ss}").WithCreate();
    Console.WriteLine($"Export to {exportDir.FullName}");
    Console.WriteLine();

    // Options for saving JSON
    var jsonOptions = new JsonSerializerOptions();
    jsonOptions.WriteIndented = true;

    // Create context instance
    var context = new ExportContext(helper, http, jsonOptions, exportDir, signal.Token);

    // Output export information
    var exportMeta = new ExportMetadata(settings.BookStack.ServiceUrl.AbsoluteUri, system.instance_id, version, exportTime);
    await exportDir.RelativeFile("export-meta.json").WriteJsonAsync(exportMeta, jsonOptions);

    // Retrieve information for each book
    await foreach (var book in context.Helper.EnumerateAllBooksAsync())
    {
        // Indicate the status.
        Console.WriteLine($"Exporting book: {Chalk.Green[book.name]} ...");

        // Export zip
        var bookZipFile = exportDir.RelativeFile($"{book.id:D4}B.{book.name.ToFileName()}.zip");
        var bookZipResult = await context.Helper.Try((c, t) => c.ExportBookZipAsync(book.id, t));
        await bookZipResult.Stream.WriteToFileAsync(bookZipFile, context.CancelToken);
    }

    Console.WriteLine($"Completed");

});

record ExportContext(BookStackClientHelper Helper, HttpClient Http, JsonSerializerOptions JsonOptions, DirectoryInfo ExportDir, CancellationToken CancelToken);
